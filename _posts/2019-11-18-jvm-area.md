---
layout: post
title: "JVM运行时数据区"
date: 2019-11-18 23:19:19 +0800
categories: Java JVM
tags: Java JVM
---

JVM就像一个小型操作系统，和真正的操作系统比如Linux有很多相似点，Linux控制多进程，JVM控制多线程，线程之间轮流切换，共享处理器。同时，还有类似于Linux的堆栈等结构来保证线程的运行。

1. Table of Contents, ordered                    
{:toc}

# PC - Program Counter
程序计数器。CPU的PC是一个Register，JVM的是一小块内存空间，但是功能是类似的，存储着线程**当前执行的字节码**的行号。

> 如果执行的是native方法，PC值为空。

> PC是JVM中唯一不会OOM的区域……这不是废话吗……倒是OOM一个让我看看……

## 线程私有？true！
PC到底是不是线程私有的？如果多个线程共享同一个PC，那当线程切换的时候，PC也得变。线程切回来，PC也得切回来。

JVM中，还是每个线程一个PC更合适。线程切换时，直接看这个线程的PC，就知道它该执行啥了。

这和CPU的PC不太一样。CPU就一个PC，存储着当前进程的**下一条执行指令**的位置，线程切换的时候，PC的值需要当做一个上下文保存起来。线程切换回来之后，再把之前保存的PC值恢复。CPU之所以这么搞，大概是因为CPU的PC是硬件，一个寄存器。CPU又不知道自己会运行多少个进程，也不可能在出厂的时候安装对应个数的PC寄存器。所以只能搞一个公用PC，运行时不停保存与切换，麻烦也没办法。

JVM维护着线程的数据结构，那么每个线程内部定义一个PC自然是比较科学且省事儿的设计。

所以JVM的PC和CPU的PC大概区别有：
- JVM每个线程一个PC，CPU所有进程共用一个PC；
- JVM的PC保存的是当前线程的当前执行字节码位置，CPU的PC保存的是当前进程的下一个要执行指令的位置；

# Stack - 栈
栈就像linux中的栈一样。栈用于保存该线程的私有信息。线程每调用一次方法，就创建一个栈帧Stack Frame，保存该方法的局部变量等，方法结束该栈帧结束。

## 线程私有？true！
栈必须是线程私有的。

## 报错
- 线程请求的栈深度大于栈本身的大小 - StavkOverFlow；
- 如果栈本身可动态拓展，但是无法从操作系统申请到足够的空间用于拓展 - OutOfMemory；

# Native Method Stack- 本地方法栈
和栈一样。只不过Stack是JVM调用Java方法（执行Java字节码）的时候用，而本地方法栈是调用native方法的时候用。

> **HotSpot JVM将本地方法栈和虚拟机栈合二为一了。**

## 线程私有？true！
和Stack一样。

## 报错
- StackOverFlow；
- OutOfMemory；

# Heap - 堆
用于存放对象实例。所有创建的对象都在这里放着。

堆是GC的主要区域，所以也有了别名：Garbage Collected Heap。

堆的大小一般JVM都会实现为可扩展的，使用`-Xms`和`-Xmx`来控制大小。（**所以这两个参数只控制堆的大小，而不是整个JVM占用空间的大小**）

## 线程私有？false！
堆是所有线程共享的。

## 报错
- OutOfMemory；

# Method Area - 方法区
方法区用来存储虚拟机加载的类信息、常量、静态变量等等。

Java1.7的时候，字符串常量池被移出方法区，放入堆中。

JVM规范没有强制方法区进行垃圾回收。（所以方法区也会被视为永久代）而且方法区回收的性价比不高，不像对Heap（尤其是Heap中的新生代）来一次垃圾回收，卓有成效，清理出非常多的空间。但是方法区并不是不回收。

方法区（永久代）的回收主要涉及两部分内容：废弃常量，无用类。

## 线程私有？false！
方法区要放所有的类信息之类的，肯定是JVM里唯一的存在，被所有线程所共享。听起来有点儿像Heap，所以它有一个别名叫Non-Heap（非堆）。

## 报错
显然，如果放的类信息过多，会OutOfMemory。

很多框架比如Spring增强类的时候，会使用CGLib等字节码技术改变类，动态生成class。运行在JVM上的动态语言比如Groovy也会持续创建类来实现语言的动态性。所以使用这些语言，更应该关注方法区OOM的问题。
- CGLib字节码增强；
- 动态语言；
- JSP（编译为Java类）；
- OSGi（同一个类文件被不同类加载器加载也会被视为不同的类）；

# 总结
总结一下线程的区域：
- PC；
- 栈；
- 本地方法栈；

线程共享的区域：
- 堆；
- 方法区；

# 附：操作系统的线程模型
操作系统的线程模型大体有三种：
- 操作系统不支持线程，只支持进程，线程实现在用户控件；
- 操作系统支持线程，线程实现在内核空间；
- 操作系统支持线程，内核空间支持线程，用户空间也可以实现线程；

## 线程在用户空间
操作系统根本不知道线程的存在，只知道进程。进程自己维持自己内部的线程信息，比如像操作系统内核维护者一张进程表一样，进程内部也要维护一张属于自己的线程表，要标记每个线程独占的资源，例如PC，线程栈，线程状态等。或者说，既然操作系统有进程控制块PCB，那这些就是线程控制块？

优点：
- 线程切换很快，无需经过操作系统；
- 程序员自己调度线程，垃圾回收等；
- 不管操作系统支不支持线程，都可以这么搞；

缺点：
- 进程中的一个线程阻塞，进行系统调用（比如缺页中断），整个进程都会被操作系统阻塞。因为对操作系统来说，是进程在向它申请系统调用；
- 如果代码写挫了，某个线程就是一个死循环，那除非进程挂了，否则这个线程不会被中断；

## 线程在内核空间
操作系统内核增加对线程的支持，同时维护进程控制块和县城控制块。

优点：
- 线程的系统调用只会阻塞该线程，不会阻塞同一进程中的其他线程；
- 程序猿不需要关心自己调度线程了；

缺点：
- 效率低，每次线程切换都要进入内核由操作系统调度；
- 线程远多于进程，容易耗尽内核的内存资源；

这种情况先线程被销毁时，仅仅是被内核标记一下，需要创建新线程时，内核再改一下标记位，改点儿其他的就行了。

突然想起了操作系统上的一句话：**线程是CPU调度的基本单位，进程是资源分配的基本单位。**

## 混合模式
既然实现在内核中，线程切得到内核里，会慢；实现在用户空间，线程申请系统调用阻塞会卡住整个进程。那不如均衡一下：**非阻塞的线程切换由进程内部负责，阻塞的线程切换由内核负责。** 完美！

同时，用户态线程数量多，内核态线程数量少，每个内核态线程负责多个用户态线程（多路复用）。

参阅：
- https://blog.csdn.net/fuzhongmin05/article/details/55802984
- https://stackoverflow.com/questions/15601155/does-linux-schedule-a-process-or-a-thread
- https://www.tldp.org/FAQ/Threads-FAQ/Support.html

JVM自己是操作系统的一个进程，在自己的进程内管理着多个线程，垃圾回收等等，再配合现代操作系统的内核线程支持，美滋滋。

# TODO
metadata area

string constant pool


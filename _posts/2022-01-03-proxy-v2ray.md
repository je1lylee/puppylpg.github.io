---
layout: post
title: "代理 - v2ray"
date: 2022-01-03 02:21:09 +0800
categories: network 
tags: network
---

之前在[代理 - shadowsocks]({% post_url 2021-11-09-proxy %})介绍了使用ss做代理的方式，部署简单，使用方便。但用了一个月之后，奇奇怪怪的事情发生了 ┓( ´∀` )┏

1. Table of Contents, ordered
{:toc}

# 奇奇怪怪的问题
部署shadowsocks的时候，开了好几个端口。8005端口用了一个月之后，突然发现没法在该端口建立起连接了：
```
> netstat -anp | grep :8005
tcp        0      0 104.225.232.103:8005    0.0.0.0:*               LISTEN      2683182/python3
tcp        0      0 104.225.232.103:8005    114.249.24.222:54649    SYN_RECV    -
tcp        0      0 104.225.232.103:8005    114.249.24.222:54566    SYN_RECV    -
tcp        0      0 104.225.232.103:8005    114.249.24.222:54544    SYN_RECV    -
tcp        0      0 104.225.232.103:8005    114.249.24.222:54984    SYN_RECV    -
tcp        0      0 104.225.232.103:8005    114.249.24.222:54524    SYN_RECV    -
tcp        0      0 104.225.232.103:8005    114.249.24.222:54779    SYN_RECV    -
tcp        0      0 104.225.232.103:8005    114.249.24.222:54868    SYN_RECV    -
tcp        0      0 104.225.232.103:8005    114.249.24.222:54988    SYN_RECV    -
tcp        0      0 104.225.232.103:8005    114.249.24.222:54805    SYN_RECV    -
tcp        0      0 104.225.232.103:8005    114.249.24.222:54525    SYN_RECV    -
tcp        0      0 104.225.232.103:8005    114.249.24.222:54818    SYN_RECV    -
tcp        0      0 104.225.232.103:8005    114.249.24.222:46250    SYN_RECV    -
tcp        0      0 104.225.232.103:8005    114.249.24.222:54978    SYN_RECV    -
tcp        0      0 104.225.232.103:8005    114.249.24.222:54832    SYN_RECV    -
tcp        0      0 104.225.232.103:8005    114.249.24.222:54567    SYN_RECV    -
tcp        0      0 104.225.232.103:8005    114.249.24.222:54913    SYN_RECV    -
tcp        0      0 104.225.232.103:8005    114.249.24.222:54878    SYN_RECV    -
tcp        0      0 104.225.232.103:8005    114.249.24.222:54499    SYN_RECV    -
tcp        0      0 104.225.232.103:8005    114.249.24.222:54930    SYN_RECV    -
tcp        0      0 104.225.232.103:8005    114.249.24.222:54850    SYN_RECV    -
tcp        0      0 104.225.232.103:8005    114.249.24.222:54974    SYN_RECV    -
tcp        0      0 104.225.232.103:8005    114.249.24.222:54939    SYN_RECV    -
tcp        0      0 104.225.232.103:8005    114.249.24.222:54926    SYN_RECV    -
tcp        0      0 104.225.232.103:8005    114.249.24.222:54534    SYN_RECV    -
tcp        0      0 104.225.232.103:8005    114.249.24.222:54609    SYN_RECV    -
tcp        0      0 104.225.232.103:8005    114.249.24.222:54769    SYN_RECV    -
tcp        0      0 104.225.232.103:8005    114.249.24.222:54886    SYN_RECV    -
tcp        0      0 104.225.232.103:8005    114.249.24.222:54639    SYN_RECV    -
tcp        0      0 104.225.232.103:8005    114.249.24.222:54943    SYN_RECV    -
tcp        0      0 104.225.232.103:8005    114.249.24.222:54970    SYN_RECV    -
tcp        0      0 104.225.232.103:8005    114.249.24.222:54597    SYN_RECV    -
tcp        0      0 104.225.232.103:8005    114.249.24.222:54488    SYN_RECV    -
udp        0      0 104.225.232.103:8005    0.0.0.0:*                           2683182/python3
```
只收到SYN，不能收到二次确认的SYN。看起来像极了SYN洪泛攻击。但是连接请求都来自我的路由出口ip，而且连接确实是我自己发起的，所以肯定不是SYN洪泛攻击。但为什么会这样，实在是不清楚。

按照[pip shadowsocks](https://pypi.org/project/shadowsocks/)的指示查看日志：
```
sudo less /var/log/shadowsocks.log
```
也没看出什么异样。

换了个ss的端口，结果就好了：
```
> netstat -anp | grep :8002
tcp        0      0 104.225.232.103:8002    0.0.0.0:*               LISTEN      2683182/python3
tcp        0      0 104.225.232.103:8002    114.249.24.222:63739    ESTABLISHED 2683182/python3
tcp        0      0 104.225.232.103:8002    114.249.24.222:61558    ESTABLISHED 2683182/python3
tcp        0      0 104.225.232.103:8002    114.249.24.222:61659    ESTABLISHED 2683182/python3
tcp        0      0 104.225.232.103:8002    114.249.24.222:61736    ESTABLISHED 2683182/python3
tcp        0      0 104.225.232.103:8002    114.249.24.222:49699    TIME_WAIT   -
tcp        0      0 104.225.232.103:8002    114.249.24.222:63026    ESTABLISHED 2683182/python3
tcp        0      0 104.225.232.103:8002    114.249.24.222:49361    ESTABLISHED 2683182/python3
tcp        0      0 104.225.232.103:8002    114.249.24.222:65437    ESTABLISHED 2683182/python3
tcp        0      0 104.225.232.103:8002    114.249.24.222:65420    ESTABLISHED 2683182/python3
tcp        0      0 104.225.232.103:8002    114.249.24.222:49247    TIME_WAIT   -
tcp        0      0 104.225.232.103:8002    114.249.24.222:61537    ESTABLISHED 2683182/python3
tcp        0      0 104.225.232.103:8002    114.249.24.222:63063    ESTABLISHED 2683182/python3
tcp        0      0 104.225.232.103:8002    114.249.24.222:49700    TIME_WAIT   -
tcp        0      0 104.225.232.103:8002    114.249.24.222:63419    ESTABLISHED 2683182/python3
tcp        0      0 104.225.232.103:8002    114.249.24.222:65416    ESTABLISHED 2683182/python3
tcp        0      0 104.225.232.103:8002    114.249.24.222:63094    ESTABLISHED 2683182/python3
tcp        0      0 104.225.232.103:8002    114.249.24.222:65415    ESTABLISHED 2683182/python3
tcp        0      0 104.225.232.103:8002    114.249.24.222:65402    ESTABLISHED 2683182/python3
tcp        0      0 104.225.232.103:8002    114.249.24.222:65428    ESTABLISHED 2683182/python3
udp        0      0 104.225.232.103:8002    0.0.0.0:*                           2683182/python3
```
为什么会这样？

据说是被GFW检测到了：
- https://github.com/shadowsocks/shadowsocks-libev/issues/1932

按照[这篇概述](https://haoel.github.io/)，找到了[websocket + tls + nginx](https://guide.v2fly.org/advanced/wss_and_web.html)的方案，把翻墙流量伪装成访问网站的流量，再使用tls加密一波，相当难被发现。

# v2ray
v2ray是一个比shadowsocks功能更强大的代理工具。可以按照[v2fly的安装指南](https://www.v2fly.org/guide/install.html)安装v2ray。

**v2ray并没有明确的client和server之分，它就是一个盒子：数据包以inbound格式进来，以outbound格式出去**。而v2ray做的主要就是协议转换的工作。**对于每一个v2ray节点，下一个节点的inbound格式就是上一个节点的outbound格式。所以它的上一个节点就是下一个节点的client，下一个节点相当于上一个节点的server**。这些节点可以连接成一串，每经过一个节点，格式进行一次转换。

所以v2ray主要配置的就是inbound和outbound所用的协议。

## 配置
server和client都按照自己的平台装上对应的v2ray，server的配置比较简单，参考[新手指南](https://www.v2fly.org/guide/start.html)：
```
{
    "inbounds": [
        {
            "port": 10086, // 服务器监听端口
            "protocol": "vmess",
            "settings": {
                "clients": [
                    {
                        "id": "b831381d-6324-4d53-ad4f-8cda48b30811"
                    }
                ]
            }
        }
    ],
    "outbounds": [
        {
            "protocol": "freedom"
        }
    ]
}
```
- 配置server监听的ip和端口；
- 入口流量是由client发来的vmess格式；
- client id相当于用户校验，是一个uuid，建议直接用[uuid generator](https://www.uuidgenerator.net/)生成。client的id要和server的一致，来自client的流量才能通过；
- 出口流量是freedom协议，相当于直连最终要访问的服务器。毕竟server是部署在海外VPS上的，直连YouTube就能访问了；

client的配置稍显麻烦：
```
{
    "inbounds": [
        {
            "port": 1080, // SOCKS 代理端口，在浏览器中需配置代理并指向这个端口
            "listen": "127.0.0.1",
            "protocol": "socks",
            "settings": {
                "udp": true
            }
        }
    ],
    "outbounds": [
        {
            "protocol": "vmess",
            "settings": {
                "vnext": [
                    {
                        "address": "server", // 服务器地址，请修改为你自己的服务器 ip 或域名
                        "port": 10086, // 服务器端口
                        "users": [
                            {
                                "id": "b831381d-6324-4d53-ad4f-8cda48b30811"
                            }
                        ]
                    }
                ]
            }
        },
        {
            "protocol": "freedom",
            "tag": "direct"
        }
    ],
    "routing": {
        "domainStrategy": "IPOnDemand",
        "rules": [
            {
                "type": "field",
                "ip": [
                    "geoip:private"
                ],
                "outboundTag": "direct"
            }
        ]
    }
}
```
- 入口流量是来自浏览器或者系统的socks协议的流量；
- 出口流量要配置成server接收的vmess协议；
- server的ip和port要配置好；
- uuid要配置成和server一样的才能验证通过；
- 强大的路由功能：上述出口流量配置为了两种类型，需要翻墙的vmess流量和直连流量，其中路由里配置私有ip的用直连流量，不需要走代理。**其他没配置的流量默认使用outbounds的第一个，也就是代理**；

可以参考[v2ray 路由](https://guide.v2fly.org/basics/routing/basics_routing.html)，把国外网站配置为翻墙，国内网站配置为直连，广告域名配置为blackhole，直接丢弃广告流量，从而实现广告屏蔽的目的。

> **client和server之间也可以使用[shadowsocks协议](https://www.v2fly.org/config/protocols/shadowsocks.html)**，这样v2ray作为client，它的server可以直接是shadowsocks服务器。
>
> client和server之间甚至还可以配置为奇奇怪怪的[http协议](https://guide.v2fly.org/basics/http.html)。

经过上述配置，流量现在的路径是这样的：
```
{浏览器} 
    <--(socks)--> 
{V2Ray 客户端 inbound <-> V2Ray 客户端 outbound} 
    <--(VMess)-->  
{V2Ray 服务器 inbound <-> V2Ray 服务器 outbound} 
    <--(Freedom)--> 
{目标网站}
```

VPS Debian安装好v2ray之后，默认配置目录是`/etc/v2ray`，作为server存在，所以把server的配置放入config.json，然后使用命令检测配置的正确性：
```
v2ray -test -config /etc/v2ray/config.json
```

以上更详细的介绍可以参考：
- v2fly大白话教程：https://guide.v2fly.org/
- v2fly新手教程：https://www.v2fly.org/guide/start.html
- v2fly配置文档：https://www.v2fly.org/config/overview.html
- 有兴趣还可以看看v2ray的开发文档：https://www.v2fly.org/developer/intro/compile.html

## 客户端
如果直接使用从[v2ray-core](https://github.com/v2fly/v2ray-core/releases)下载的v2ray作为client，用起来不是很方便。

之前买别人的代理的时候，用了基于v2ray的client软件：
- windows用的是v2rayN：https://github.com/2dust/v2rayN；
- Android用的是v2rayNG：https://github.com/2dust/v2rayNG；

都是有图形界面的，配置起来相对容易很多。

实际使用的时候，建议先下载一个v2ray-core的client，配置好config.json，作为client启动。此时的代理只是浏览器的代理，不是系统代理，所以chrome使用switchOmega配置好浏览器代理为v2ray-core的client服务地址（默认localhost:1080）之后，就可以成功访问YouTube了。至此，证明client配置是成功的。

之后以v2rayN为例，选择“添加vmess服务器”，然后直接选择“导入配置文件”，把刚刚配置的config.json导入进来，就成功添加了v2ray客户端可以连接的server。通过v2rayN的图形界面，可以很方便配置代理为系统代理，而不只是浏览器代理。

配过v2rayN，v2rayNG也大差不差了。

# websocket + tls + web(eg: nginx)
- https://guide.v2fly.org/advanced/wss_and_web.html

## websocket
websocket是和http同等级的应用层协议，主要是为了解决http只能由client主动发起而不能反过来的问题。这就导致了client从server知道一个状态的实时动态变化过程，只能通过不断轮询的方式。而websocket则可以让server主动push消息给client：
- websocket的形象解释：https://www.zhihu.com/question/20215561
- https://www.ruanyifeng.com/blog/2017/05/websocket.html

但是上述文章似乎并没有解释websocket之所以能这么做的原理。这个以后再探讨，目前只需要知道：
1. websocket类似http；
2. websocket + tls类似http + tls，即https；
3. websocket利用http完成握手阶段，兼容http，比http多一些header；

所以websocket + tls + nginx，本质上就是 **通过v2ray客户端让流量伪装成websocket格式的流量，并使用tls加密，打到nginx上，而真正的v2ray服务器则隐藏在nginx后面**。当然也不一定是nginx，apache也行。

整体配置主要就两步：
1. 配置v2ray客户端和nginx之间通过websocket + tls方式通信。nginx配置http可以参考[折腾小服务器 - netdata与nginx]({% post_url 2021-12-08-vps-netdata-nginx %})，数字证书配置方式可以参考[折腾小服务器 - nginx与https]({% post_url 2021-12-11-vps-nginx-https %})；
2. 配置nginx反向代理到v2ray服务器；

## 配置nginx
nginx之前已经配置443端口为https了，所以websocket + tls可以配置在一起：
```
upstream netdata {
    server 127.0.0.1:19999;
    keepalive 64;
}

upstream v2ray-ws {
    server 127.0.0.1:10086;
    keepalive 64;
}

server {
    listen 80;
    listen 443 ssl;
    # uncomment the line if you want nginx to listen on IPv6 address
    listen [::]:80;
    listen [::]:443 ssl;

    # the virtual host name of this subfolder should be exposed
    #server_name netdata.example.com;
    server_name puppylpg.xyz;

    # use password to access
    # auth_basic "Protected";
    # auth_basic_user_file passwords;

    # CA: LET'S ENCRYPT
    ssl_certificate /etc/letsencrypt/live/puppylpg.xyz/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/puppylpg.xyz/privkey.pem;

    location = /netdata {
        return 301 /netdata/;
    }

    location ~ /netdata/(?<ndpath>.*) {
        proxy_redirect off;
        proxy_set_header Host $host;

        proxy_set_header X-Forwarded-Host $host;
        proxy_set_header X-Forwarded-Server $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_http_version 1.1;
        proxy_pass_request_headers on;
        proxy_set_header Connection "keep-alive";
        proxy_store off;
        proxy_pass http://netdata/$ndpath$is_args$args;

        gzip on;
        gzip_proxied any;
        gzip_types *;
    }

    location ~ /v2ray {

        if ($http_upgrade != "websocket") { # WebSocket协商失败时返回404
            return 404;
        }

        proxy_redirect off;
        proxy_set_header Host $host;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        # Show real IP in v2ray access.log
        proxy_set_header X-Real-IP $remote_addr;

        proxy_set_header X-Forwarded-Host $host;
        proxy_set_header X-Forwarded-Server $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_pass_request_headers on;
        proxy_set_header Connection "keep-alive";
        proxy_store off;
        proxy_pass http://v2ray-ws;

        gzip on;
        gzip_proxied any;
        gzip_types *;
    }
}
```
主要配置：
1. v2ray的服务地址：v2ray-ws；
2. 域名 + `/v2ray`路径作为对v2ray-ws访问的请求；
3. 设置Upgrade header，这是websocket比http协议多的header；
4. **如果没有`Upgrade: websocket` header，说明它不是websocket协议，而是http协议**。我们配置的是websocket，所以对于http协议，直接返回404；

> 之前给nginx的http访问配置了basic认证，这里关掉了。不然websocket协议的访问也需要basic认证，而v2ray客户端好像不支持这个，导致nginx报错401 unauthorized：`114.249.24.222 - - [02/Jan/2022:05:45:15 -0500] "GET /v2ray HTTP/1.1" 401 179 "-" "Go-http-client/1.1"`。

## v2ray服务器配置
照着这个配就行了：
- https://guide.v2fly.org/advanced/wss_and_web.html#%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE

注意网络inbounds配置为ws，路径配置为`/v2ray`，和nginx保持一致：
```
{
  "inbounds":[
    {
      "listen":"127.0.0.1", //只监听 127.0.0.1，避免除本机外的机器探测到开放了 10000 端口
      "port":10086, // 服务器监听端口
      "protocol":"vmess",
      "settings":{
        "clients":[
          {
            "id":"需要一个uuid",
			"alterId": 64
          }
        ]
      },
	  "streamSettings": {
        "network": "ws",
        "wsSettings": {
        "path": "/v2ray"
        }
      }
    }
  ],
  "outbounds":[
    {
      "protocol":"freedom"
    }
  ]
}
```

v2ray支持tls，但是这里只配置了websocket没有配置tls，因为客户端和nginx之间已经是tls了，**nginx和v2ray服务都在同一台机器上，没必要还使用tls**。

**另外v2ray服务器只绑定了127.0.0.1的10086端口，这样服务根本不对外暴露，也就不可能被检测到**。

## v2ray客户端配置
照着这个配就行了：
- https://guide.v2fly.org/advanced/wss_and_web.html#%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%85%8D%E7%BD%AE

注意网络outbounds配置为ws + tls，路径配置为`/v2ray`，和nginx保持一致：
```
{
  "inbounds":[
    {
      "port":1080, // SOCKS 代理端口，在浏览器中需配置代理并指向这个端口
      "listen":"127.0.0.1",
      "protocol":"socks",
      "sniffing": {
        "enabled": true,
        "destOverride": ["http", "tls"]
      },
      "settings": {
        "auth": "noauth",
        "udp": false
      }
    }
  ],
  "outbounds":[
    {
      "protocol":"vmess",
      "settings":{
        "vnext":[
          {
            "address":"puppylpg.xyz", // 服务器地址，请修改为你自己的服务器 ip 或域名
            "port":443, // 服务器端口
            "users":[
              {
                "id":"需要一个uuid",
				"alterId": 64
              }
            ]
          }
        ]
      },
	  "streamSettings": {
        "network": "ws",
        "security": "tls",
        "wsSettings": {
          "path": "/v2ray"
        }
	  }
    },
    {
      "protocol":"freedom",
      "tag":"direct"
    }
  ],
  "routing":{
    "domainStrategy":"IPOnDemand",
    "rules":[
      {
        "type":"field",
        "ip":[
          "geoip:private"
        ],
        "outboundTag":"direct"
      }
    ]
  }
}
```
客户端配置的websocket需要使用tls，因为和nginx之间的通信是经过公网的远程通信。

> 出口协还是vmess，配置成了websocket + tls，**所以是 vmess over websocket over tls over tcp？**

之后重启v2ray和nginx就可以了。

可看到v2ray和nginx之间建立起了连接，且V2ray只绑定到了loop地址：
```
root@pokemon /e/n/sites-enabled# netstat -anp | grep :10086
tcp        0      0 127.0.0.1:10086         0.0.0.0:*               LISTEN      3225973/v2ray
tcp        0      0 127.0.0.1:10086         127.0.0.1:45362         ESTABLISHED 3225973/v2ray
tcp        0      0 127.0.0.1:45362         127.0.0.1:10086         ESTABLISHED 3243463/nginx: work
tcp        0      0 127.0.0.1:44320         127.0.0.1:10086         ESTABLISHED 3243463/nginx: work
tcp        0      0 127.0.0.1:10086         127.0.0.1:44320         ESTABLISHED 3225973/v2ray
```

# 其他
客户端还可以和服务器之间用以下协议通信：
- 伪装成http：https://guide.v2fly.org/advanced/httpfake.html
    + 这个很好玩的样子，和直接使用http还不一样，是伪装成http。vmess over http？有空可以研究一下：https://www.v2fly.org/config/transport.html#streamsettingsobject
- tcp + tls：https://guide.v2fly.org/advanced/tls.html
- tcp + tls + web：https://guide.v2fly.org/advanced/tcp_tls_web.html
    + 和上面的websocket + tls + web类似，只不过用了传输层的tcp而不是应用层的websocket；
- 直接使用websocket：https://guide.v2fly.org/advanced/websocket.html
- 直接使用http2：https://guide.v2fly.org/advanced/h2.html
    + **据说http2贼快！可以试试：https://http2.akamai.com/demo**。
- http2 + tls + web：https://guide.v2fly.org/advanced/h2_tls_web.html
    + **既然http2贼快，那就可以试试用它取代websocket + tls + web的效果**。

其他还可以探索一些v2ray的功能，比如：
- 统计：https://www.v2fly.org/config/stats.html

# 感谢
v2ray果然很强大！比shadowsocks要复杂不少。

GFW真是一个学习、巩固、拓展计算机网络知识的好素材，经历这些磨难之后，发现计算机网络的知识更加强悍了。


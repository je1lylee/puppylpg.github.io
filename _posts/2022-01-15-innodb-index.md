---
layout: post
title: "Innodb - 索引"
date: 2022-01-15 02:54:56 +0800
categories: mysql innodb
tags: mysql innodb
---

在[Innodb - 页]({% post_url 2022-01-14-innodb-page %})中，介绍了页内行记录的排列方式——类似于一个拥有一层目录的跳表，可以加速行的定位。现在页与页之间也构成双向链表，**类比页内跳表，可以在页与页之间构建一个页间跳表，以加速页的定位**。

1. Table of Contents, ordered
{:toc}

# 索引
同样的思路，每个page可以选出一个带头大哥，innodb选了page里 **用户插入的** 主键最小的那条记录（page内最小的记录是infimum），所以可以称为“page的带头小哥”，记录它的：
- 主键值；
- 页号；

> 这里并没有完整抽出带头小哥的记录内容，只需要知道它的主键和页号就行了，具体内容去它页号所代表的page里找。

每个页选一个带头小哥，构成了页的一级目录。现在整个结构长得开始像跳表了。

## 抽出来的行记录，还是行记录
这些带头小哥也用指针连起来，又构成了一个有序双向链表！接着精彩的地方来了——**这些带头小哥长得跟行记录很像，那相邻的一堆带头小哥们也可以放到page里，就像行记录放到page里一样**！如此一来，小哥们就可以像其他page一样管理了！

之前说过，带头小哥的行记录内容比较简单，**只记录了两个列**：
- 主键值；
- 页号；

**它没有记录数据的行记录的完整数据信息（所有的列的内容）**，所以为了和数据行以示区分，它的metadata的`record_type=1`，标志着这个行是一个目录行，而不是数据行。

> [Innodb - 行]({% post_url 2022-01-13-innodb-row %})里介绍了record_type有四种：0-用户插入的数据记录；1-目录项记录；2-infimum；3-supremum。

## 抽出来的记录组成的page，还是page
带头小哥多了，和用户插入的数据行一样，一页也放不下了，自然就组成了多个page。另一个精彩的地方来了——是不是还可以继续再给这些page抽出来一个个代表这些page的带头小哥？相当于给刚刚装着带头小哥的页又创建了新一层目录……

这样层层构建，就是一个长得像跳表的东西！它就是B+树：
- 最底层的存放数据项的页是B+树的叶节点，记录的是数据的完整内容；
- 叶节点上层的数据页是B+树中间结点，他们都是存放目录项的页；

> 当开始套娃的时候，人类的脑子逐渐跟不上的时候，精彩的事情就来了！高分电影不都是这个套路吗？而这些被人们奉若神明的高分套路，在计算机里可太平平无奇了:D

## 那它为什么不叫跳表？
尬住了……一直说它像跳表，怎么像到最后，它叫B+树了？

B+树和跳表确实很像，都有多层，上一层是下一层的目录，所以节点自下往上越来越少。

他们最大的不同就是 **b+树是以页为单位管理的，所以特别适合磁盘存储**。一次读取一页，减少磁盘io。而跳表没有以页为单位的概念，所以适合放在内存里。因此，redis这种内存型数据库使用跳表，MySQL这种磁盘存储型数据库使用b+树。

> 还有一些其他区别，比如b+树是一棵树，有一个根节点（节点里有多条目录项），而跳表虽然也是多层，但好像永远从第一个节点的最高层开始查找。这也意味着跳表有多少层，第一个节点有就多少层。
>
> 我编的。具体是不是这样，等以后好好研究跳表的时候再说。

- https://stackoverflow.com/a/23814116/7676237

## 层级
b+树听起来是一个很多层的结构，但真的很多层吗？

假设一个页能存放100条数据记录，或者1000条目录项记录：
1. 一层B+树，叶子节点能存放100条数据；
2. 两层B+树，叶子节点能存放100*1000=10w条数据；
3. 三层B+树，叶子节点能存放10w*1000=1亿条数据；
4. 四层B+树，叶子节点能存放1亿*1000=1000亿条数据；

事实上一个表一般最多存几千万条，也就是说3层B+数就够了。此时按照主键寻找一条记录，从根目录起，只需要找三层，也就是3次二分查找就够了！非常快！

## 根节点怎么找
看出来了，每一次查找都是从根节点开始找的。那怎么找到根节点？

当插入第一条记录的时候，innodb创建了第一个页，存放数据。这种情况下，其实是没有目录项的。

> 一页都放不满，要什么目录项！直接在页内做个二分查找就够了。

后来随着数据的增多，一页放不下，就开始 **页分裂**，此时出现了下一层节点。**而原来创建的第一个节点，就成了树的根节点！后面再怎么分裂下去，根节点永远是第一个创建的页，所以它的页号永远不变**。

那就简单了，只要在为表插入第一条数据，创建第一个页的时候，把页号记下来，就可以知道聚簇索引根节点的页号了。

# 索引类型
## 聚簇索引
这种B+树，子节点是数据记录项，其他节点是目录项，索引本身也是数据，所以被称为聚簇索引。

**以主键为顺序构造的索引，就是聚簇索引，而这种索引是默认创建的**。之前[Innodb - 行]({% post_url 2022-01-13-innodb-row %})说如果用户不显式创建主键，也没有unique not null项，就会自己创建一个隐藏列`row_id`作为主键。**innodb对主键这么执着，就是为了在这里创建聚簇索引**。

> 索引即数据，数据即索引。**存储数据项的时候，默认就构建了一个B+树索引**。

## 二级索引
根据MySQL的语法，还可以为其他列构建索引，以加快对该列的搜索。这种情况下，不是以主键构造的索引，而是按照该列的值新建了一棵B+树。

**又一棵B+树，它的叶子节点里也都是用户输入的数据项吗**？显然不是，否则每多建一个索引，MySQL数据空间占用岂不是翻倍了？

显然，这里是要用指针的。**所以这种B+树的叶子节点的数据项实际就两列**：
- 目标索引列的值；
- 对应的主键值；

**也就是说，它的数据项是不完整的原始数据项，只有其中的主键列和目标索引列**。

**而非叶子节点的目录项和聚簇索引没什么差别**：
- 目标索引列的值；
- 对应的主键值；
- 页号；

> 这里需要主键值，主要是因为索引列可能有重复值，搭配上主键，就是唯一的了。此时就算插入相同索引列值的数据，也可以再按照主键值确定插入的前后位置。

这种B+树索引叫二级索引：每次按照目标索引列查记录，先查二级索引，定位到主键值，再根据主键值查找聚簇索引，查找原始数据项。

> 所以它叫二级索引，因为还要再用一次聚簇索引。而这种再查聚簇索引的过程，叫做 **回表**，就好像又回到了原始的数据表再查一次一样。

二级索引和聚簇索引的另一个区别在于，**因为索引列不是主键，所以可能有重复值，因此查找索引列的值的时候，查到的可能是很多条主键值，那就要根据每一条主键值进行多次回表**。

## 联合索引
另一种MySQL创建索引的语法，以多个列共同建立一个索引，叫做联合索引。

**它的思路和二级索引是一模一样的，毕竟换个角度来看，二级索引就是只有一个索引列的联合索引**。

> 二级索引只是表面上看只有一个索引列，其实更准确点儿说，是索引列和主键值的联合索引。

因此联合索引的非叶子节点：
- 各个联合索引列的值；
- 主键值；
- 页号；

联合索引的叶子节点的值：
- 各个联合索引列的值；
- 主键值；

# MyISAM：索引是索引，数据是数据
MyISAM和innodb不一样，它的行也是连续存放的，但没有页的概念，也不构成链表。

MyISAM也会默认按照主键建立索引，索引也是B+树，**但是树是独立于行记录的，它的叶子节点不是行记录数据，而是主键值、行地址。** 所以MyISAM的索引就像Innodb的二级索引一样，想查到原始数据，**一定要进行一次回表**！但是因为它记录了数据行的行地址，所以直接就定位到行了，而不是像Innodb一样从聚簇索引的根一层层找到叶子节点的原始数据。

> 所以其实MyISAM的速度和Innodb没啥太大区别。

而MyISAM按照非主键建立的索引，和MyISAM按照主键建立的索引几乎没区别，就是把主键换成了索引列。MyISAM的二级索引不需要存储主键值了，因为它也记录下了数据行的行地址，直接就可以定位到数据行了。

> **所以MyISAM里的所有索引都相当于Innodb的二级索引。而且索引是不是以主键构建的，也并不重要了。有行地址了，还要主键干啥？** 而Innodb主键所在的聚簇索引地位特殊，所有的二级索引都要先找到主键，再拿着主键去聚簇索引找真实值。

MyISAM的索引是单独的索引文件，数据是数据文件，二者物理上是分离的，所以索引是索引，数据是数据。

# 语法
使用`KEY`或者`INDEX`创建索引，二者等价。

新建：
```
CREATE TABLE t1 (
    c1 INT,
    c2 INT
    PRIMARY KEY(c1),
    INDEX idx_c2(c2)
) CHARSET=utf8mb4 ENGINE=INNODB ROW_FORMAT=COMPACT;
```
index最好自己起个名字，最好是idx+列名。否则MySQL会自动给index起个名字。有名字了，删也好删：
```
ALTER TABLE t1 DROP INDEX idx_c2;
```

新增：
```
ALTER TABLE t1 ADD (INDEX|KEY) idx_c2(c2);
```

